# Deployment Automation Framework for AI-Generated Projects
# Complete deployment pipeline and automation scripts

metadata:
  name: "Deployment Automation Framework"
  version: "1.0.0"
  description: "Automated deployment pipeline for generated microservices"

# Deployment Pipeline Stages
deployment_pipeline:
  # Stage 1: Pre-deployment Validation
  pre_deployment:
    description: "Validate environment and prerequisites"
    steps:
      1:
        name: "environment_check"
        description: "Check deployment environment requirements"
        validations:
          - "Docker and Docker Compose installed"
          - "Sufficient disk space available"
          - "Required ports are available"
          - "Environment variables are set"

      2:
        name: "configuration_validation"
        description: "Validate configuration files"
        validations:
          - ".env file exists and is complete"
          - "docker-compose.yml is valid"
          - "Service configurations are correct"

      3:
        name: "network_check"
        description: "Validate network connectivity"
        validations:
          - "Internet connectivity for image pulls"
          - "DNS resolution working"
          - "No port conflicts"

  # Stage 2: Infrastructure Setup
  infrastructure_setup:
    description: "Set up required infrastructure services"
    steps:
      1:
        name: "pull_base_images"
        description: "Pull required Docker images"
        images:
          - "postgres:15-alpine"
          - "mongo:7.0"
          - "rabbitmq:3.12-management"
          - "redis:7-alpine"

      2:
        name: "create_networks"
        description: "Create Docker networks"
        networks:
          - "microservices_network"

      3:
        name: "create_volumes"
        description: "Create persistent volumes"
        volumes:
          - "postgres_data"
          - "mongodb_data"
          - "rabbitmq_data"
          - "redis_data"

  # Stage 3: Service Deployment
  service_deployment:
    description: "Deploy services in correct order"
    deployment_order:
      1:
        stage: "infrastructure_services"
        services: ["postgres", "mongodb", "rabbitmq", "redis"]
        strategy: "parallel"
        wait_for: "health_checks"

      2:
        stage: "data_services"
        services: ["db_postgres_service", "db_mongo_service"]
        strategy: "parallel"
        depends_on: "infrastructure_services"
        wait_for: "health_checks"

      3:
        stage: "business_services"
        services: ["{{api_service}}", "{{bot_service}}", "{{worker_service}}"]
        strategy: "parallel"
        depends_on: "data_services"
        wait_for: "health_checks"

      4:
        stage: "observability_services"
        services: ["prometheus", "grafana", "jaeger"]
        strategy: "parallel"
        depends_on: "business_services"
        optional: true

  # Stage 4: Post-deployment Validation
  post_deployment:
    description: "Validate successful deployment"
    validations:
      - "All services are running"
      - "Health checks are passing"
      - "Service-to-service communication working"
      - "Database migrations completed"
      - "Initial data seeding successful"

# Deployment Scripts
deployment_scripts:
  # Main deployment script
  deploy_script: |
    #!/bin/bash
    # {{project_title}} Deployment Script
    # Automated deployment with validation and monitoring

    set -e

    # Colors for output
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color

    # Configuration
    PROJECT_NAME="{{project_name}}"
    COMPOSE_FILE="docker-compose.yml"
    ENV_FILE=".env"

    # Logging function
    log() {
        echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
    }

    error() {
        echo -e "${RED}[ERROR]${NC} $1" >&2
    }

    success() {
        echo -e "${GREEN}[SUCCESS]${NC} $1"
    }

    warning() {
        echo -e "${YELLOW}[WARNING]${NC} $1"
    }

    # Pre-deployment checks
    pre_deployment_checks() {
        log "Starting pre-deployment checks..."

        # Check if Docker is installed and running
        if ! command -v docker &> /dev/null; then
            error "Docker is not installed"
            exit 1
        fi

        if ! docker info &> /dev/null; then
            error "Docker is not running"
            exit 1
        fi

        # Check if Docker Compose is available
        if ! command -v docker-compose &> /dev/null; then
            error "Docker Compose is not installed"
            exit 1
        fi

        # Check if .env file exists
        if [ ! -f "$ENV_FILE" ]; then
            error ".env file not found. Please copy .env.example to .env and configure it."
            exit 1
        fi

        # Check if docker-compose.yml exists
        if [ ! -f "$COMPOSE_FILE" ]; then
            error "docker-compose.yml not found"
            exit 1
        fi

        # Validate docker-compose.yml
        if ! docker-compose -f "$COMPOSE_FILE" config &> /dev/null; then
            error "Invalid docker-compose.yml configuration"
            exit 1
        fi

        # Check available disk space (minimum 5GB)
        available_space=$(df . | tail -1 | awk '{print $4}')
        if [ "$available_space" -lt 5242880 ]; then
            warning "Low disk space available. At least 5GB recommended."
        fi

        success "Pre-deployment checks passed"
    }

    # Check port availability
    check_ports() {
        log "Checking port availability..."

        ports=({{required_ports}})

        for port in "${ports[@]}"; do
            if netstat -tuln | grep ":$port " &> /dev/null; then
                error "Port $port is already in use"
                exit 1
            fi
        done

        success "All required ports are available"
    }

    # Pull and build images
    prepare_images() {
        log "Pulling and building Docker images..."

        # Pull base images
        docker-compose -f "$COMPOSE_FILE" pull

        # Build custom services
        docker-compose -f "$COMPOSE_FILE" build

        success "Images prepared successfully"
    }

    # Deploy infrastructure services
    deploy_infrastructure() {
        log "Deploying infrastructure services..."

        # Start infrastructure services
        docker-compose -f "$COMPOSE_FILE" up -d postgres mongodb rabbitmq redis

        # Wait for services to be healthy
        log "Waiting for infrastructure services to be ready..."
        wait_for_service "postgres:5432" "PostgreSQL"
        wait_for_service "mongodb:27017" "MongoDB"
        wait_for_service "rabbitmq:5672" "RabbitMQ"
        wait_for_service "redis:6379" "Redis"

        success "Infrastructure services deployed successfully"
    }

    # Deploy data services
    deploy_data_services() {
        log "Deploying data services..."

        # Start data services
        docker-compose -f "$COMPOSE_FILE" up -d db_postgres_service db_mongo_service

        # Wait for data services to be ready
        wait_for_health_check "http://localhost:8001/health" "PostgreSQL Data Service"
        wait_for_health_check "http://localhost:8002/health" "MongoDB Data Service"

        success "Data services deployed successfully"
    }

    # Deploy business services
    deploy_business_services() {
        log "Deploying business services..."

        # Start business services
        {{business_services_deployment}}

        # Wait for business services to be ready
        {{business_services_health_checks}}

        success "Business services deployed successfully"
    }

    # Deploy observability services (optional)
    deploy_observability() {
        if [ "$DEPLOY_OBSERVABILITY" = "true" ]; then
            log "Deploying observability services..."

            docker-compose -f "$COMPOSE_FILE" up -d prometheus grafana jaeger

            success "Observability services deployed successfully"
        fi
    }

    # Wait for service to be available
    wait_for_service() {
        local service=$1
        local name=$2
        local max_attempts=30
        local attempt=1

        while [ $attempt -le $max_attempts ]; do
            if docker-compose exec -T $(echo $service | cut -d: -f1) sh -c "nc -z localhost $(echo $service | cut -d: -f2)" &> /dev/null; then
                success "$name is ready"
                return 0
            fi

            log "Waiting for $name... (attempt $attempt/$max_attempts)"
            sleep 10
            ((attempt++))
        done

        error "$name failed to start within expected time"
        return 1
    }

    # Wait for HTTP health check
    wait_for_health_check() {
        local url=$1
        local name=$2
        local max_attempts=30
        local attempt=1

        while [ $attempt -le $max_attempts ]; do
            if curl -f -s "$url" &> /dev/null; then
                success "$name health check passed"
                return 0
            fi

            log "Waiting for $name health check... (attempt $attempt/$max_attempts)"
            sleep 10
            ((attempt++))
        done

        error "$name health check failed"
        return 1
    }

    # Post-deployment validation
    post_deployment_validation() {
        log "Running post-deployment validation..."

        # Check all services are running
        if docker-compose -f "$COMPOSE_FILE" ps | grep -q "Exit"; then
            error "Some services failed to start properly"
            docker-compose -f "$COMPOSE_FILE" ps
            return 1
        fi

        # Run integration tests if available
        if [ -f "scripts/integration-tests.sh" ]; then
            log "Running integration tests..."
            ./scripts/integration-tests.sh
        fi

        success "Post-deployment validation completed"
    }

    # Main deployment function
    main() {
        log "Starting deployment of $PROJECT_NAME..."

        pre_deployment_checks
        check_ports
        prepare_images
        deploy_infrastructure
        deploy_data_services
        deploy_business_services
        deploy_observability
        post_deployment_validation

        success "🎉 $PROJECT_NAME deployed successfully!"

        log "Service URLs:"
        {{service_urls_output}}

        log "To view logs: docker-compose logs -f"
        log "To stop services: docker-compose down"
    }

    # Execute main function
    main "$@"

  # Health check script
  health_check_script: |
    #!/bin/bash
    # {{project_title}} Health Check Script

    # Configuration
    PROJECT_NAME="{{project_name}}"

    # Health check URLs
    declare -A HEALTH_CHECKS=(
        {{health_check_endpoints}}
    )

    # Colors
    GREEN='\033[0;32m'
    RED='\033[0;31m'
    YELLOW='\033[1;33m'
    NC='\033[0m'

    # Check service health
    check_service_health() {
        local name=$1
        local url=$2

        if curl -f -s "$url" &> /dev/null; then
            echo -e "${GREEN}✅ $name${NC} - Healthy"
            return 0
        else
            echo -e "${RED}❌ $name${NC} - Unhealthy"
            return 1
        fi
    }

    # Main health check
    main() {
        echo "🏥 Health Check for $PROJECT_NAME"
        echo "=================================="

        failed_services=0

        for service in "${!HEALTH_CHECKS[@]}"; do
            if ! check_service_health "$service" "${HEALTH_CHECKS[$service]}"; then
                ((failed_services++))
            fi
        done

        echo "=================================="

        if [ $failed_services -eq 0 ]; then
            echo -e "${GREEN}✅ All services are healthy${NC}"
            exit 0
        else
            echo -e "${RED}❌ $failed_services service(s) are unhealthy${NC}"
            exit 1
        fi
    }

    main "$@"

  # Monitoring script
  monitoring_script: |
    #!/bin/bash
    # {{project_title}} Monitoring Script

    PROJECT_NAME="{{project_name}}"

    # Monitor system resources
    monitor_resources() {
        echo "📊 System Resources"
        echo "==================="

        # CPU usage
        cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | awk -F'%' '{print $1}')
        echo "CPU Usage: ${cpu_usage}%"

        # Memory usage
        memory_usage=$(free | grep Mem | awk '{printf("%.1f", $3/$2 * 100.0)}')
        echo "Memory Usage: ${memory_usage}%"

        # Disk usage
        disk_usage=$(df -h . | tail -1 | awk '{print $5}')
        echo "Disk Usage: $disk_usage"

        echo
    }

    # Monitor Docker containers
    monitor_containers() {
        echo "🐳 Docker Containers"
        echo "===================="

        docker-compose ps

        echo
    }

    # Monitor service logs
    monitor_logs() {
        echo "📝 Recent Service Logs"
        echo "======================"

        # Show last 10 lines from each service
        {{log_monitoring_commands}}

        echo
    }

    # Main monitoring function
    main() {
        echo "🔍 Monitoring $PROJECT_NAME"
        echo "============================="
        echo

        monitor_resources
        monitor_containers
        monitor_logs

        echo "For live logs: docker-compose logs -f [service_name]"
        echo "For detailed container stats: docker stats"
    }

    main "$@"

# Environment Management
environment_management:
  # Environment configuration script
  env_setup_script: |
    #!/bin/bash
    # {{project_title}} Environment Setup

    # Generate secure passwords
    generate_password() {
        openssl rand -base64 32
    }

    # Generate JWT secret
    generate_jwt_secret() {
        openssl rand -hex 64
    }

    # Setup environment file
    setup_env() {
        if [ -f ".env" ]; then
            echo "⚠️  .env file already exists. Backup created as .env.backup"
            cp .env .env.backup
        fi

        echo "🔧 Setting up environment configuration..."

        # Generate secure credentials
        POSTGRES_PASSWORD=$(generate_password)
        MONGO_PASSWORD=$(generate_password)
        RABBITMQ_PASSWORD=$(generate_password)
        REDIS_PASSWORD=$(generate_password)
        JWT_SECRET=$(generate_jwt_secret)

        # Create .env file
        cat > .env << EOF
    # {{project_title}} Environment Configuration
    # Generated on $(date)

    # Project Settings
    PROJECT_NAME={{project_name}}
    ENVIRONMENT=development
    LOG_LEVEL=INFO

    # Database Configuration
    POSTGRES_USER={{project_name}}_user
    POSTGRES_PASSWORD=$POSTGRES_PASSWORD

    MONGO_USER={{project_name}}_user
    MONGO_PASSWORD=$MONGO_PASSWORD

    # Message Broker
    RABBITMQ_USER={{project_name}}_user
    RABBITMQ_PASSWORD=$RABBITMQ_PASSWORD

    # Cache
    REDIS_PASSWORD=$REDIS_PASSWORD

    # Security
    JWT_SECRET_KEY=$JWT_SECRET

    # Service Configuration
    {{service_environment_variables}}

    # External Services
    {{external_service_variables}}
    EOF

        echo "✅ Environment configuration created successfully"
        echo "📝 Please review and modify .env file as needed"
        echo "🔐 Secure passwords have been generated automatically"
    }

    setup_env

  # Environment validation script
  env_validation_script: |
    #!/bin/bash
    # Validate environment configuration

    validate_env_var() {
        local var_name=$1
        local var_value=${!var_name}

        if [ -z "$var_value" ]; then
            echo "❌ $var_name is not set"
            return 1
        else
            echo "✅ $var_name is set"
            return 0
        fi
    }

    # Load environment variables
    if [ -f ".env" ]; then
        set -a
        source .env
        set +a
    else
        echo "❌ .env file not found"
        exit 1
    fi

    echo "🔍 Validating environment configuration..."

    # Required variables
    required_vars=(
        {{required_environment_variables}}
    )

    failed_vars=0

    for var in "${required_vars[@]}"; do
        if ! validate_env_var "$var"; then
            ((failed_vars++))
        fi
    done

    if [ $failed_vars -eq 0 ]; then
        echo "✅ All environment variables are properly configured"
    else
        echo "❌ $failed_vars environment variable(s) are missing or invalid"
        exit 1
    fi

# Rollback and Recovery
rollback_procedures:
  # Rollback script
  rollback_script: |
    #!/bin/bash
    # {{project_title}} Rollback Script

    PROJECT_NAME="{{project_name}}"

    # Rollback to previous version
    rollback() {
        echo "🔄 Starting rollback for $PROJECT_NAME..."

        # Stop current services
        echo "Stopping current services..."
        docker-compose down

        # Restore previous configuration if backup exists
        if [ -f "docker-compose.yml.backup" ]; then
            echo "Restoring previous configuration..."
            cp docker-compose.yml.backup docker-compose.yml
        fi

        if [ -f ".env.backup" ]; then
            echo "Restoring previous environment..."
            cp .env.backup .env
        fi

        # Start services with previous configuration
        echo "Starting services with previous configuration..."
        docker-compose up -d

        echo "✅ Rollback completed"
    }

    # Emergency stop
    emergency_stop() {
        echo "🚨 Emergency stop initiated..."
        docker-compose down --remove-orphans
        echo "✅ All services stopped"
    }

    case "$1" in
        rollback)
            rollback
            ;;
        emergency-stop)
            emergency_stop
            ;;
        *)
            echo "Usage: $0 {rollback|emergency-stop}"
            exit 1
            ;;
    esac

# Deployment Validation
deployment_validation:
  # Integration test script
  integration_test_script: |
    #!/bin/bash
    # Integration tests for deployed services

    # Test service communication
    test_service_communication() {
        echo "🔗 Testing service communication..."

        # Test API to PostgreSQL service
        if curl -f -s "http://localhost:8000/api/health" &> /dev/null; then
            echo "✅ API service is responsive"
        else
            echo "❌ API service is not responding"
            return 1
        fi

        # Test data service endpoints
        {{service_communication_tests}}

        return 0
    }

    # Test database connectivity
    test_database_connectivity() {
        echo "🗄️  Testing database connectivity..."

        # Test PostgreSQL
        if docker-compose exec -T postgres pg_isready -U {{postgres_user}} &> /dev/null; then
            echo "✅ PostgreSQL is accessible"
        else
            echo "❌ PostgreSQL is not accessible"
            return 1
        fi

        # Test MongoDB
        if docker-compose exec -T mongodb mongosh --eval "db.adminCommand('ping')" &> /dev/null; then
            echo "✅ MongoDB is accessible"
        else
            echo "❌ MongoDB is not accessible"
            return 1
        fi

        return 0
    }

    # Run all tests
    main() {
        echo "🧪 Running integration tests..."

        test_database_connectivity
        test_service_communication

        echo "✅ Integration tests completed"
    }

    main "$@"

# Template Variables for Generation
template_variables:
  project_variables:
    project_name: "Generated project name (underscore_case)"
    project_title: "Human-readable project title"
    required_ports: "List of ports used by services"

  service_variables:
    api_service: "Name of API service (if generated)"
    bot_service: "Name of bot service (if generated)"
    worker_service: "Name of worker service (if generated)"

  environment_variables:
    service_environment_variables: "Service-specific environment variables"
    external_service_variables: "External API and service configurations"
    required_environment_variables: "List of required environment variables"

  health_check_variables:
    health_check_endpoints: "Map of service names to health check URLs"
    service_urls_output: "Display of accessible service URLs"
    business_services_deployment: "Commands to deploy business services"
    business_services_health_checks: "Health check commands for business services"