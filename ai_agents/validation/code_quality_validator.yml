# Code Quality Validation Framework
# Validates generated code for quality, standards, and best practices

metadata:
  name: "Code Quality Validator"
  version: "1.0.0"
  description: "Comprehensive code quality validation for generated microservices"

# Python Code Quality Standards
python_quality:
  # Syntax and Structure Validation
  syntax_validation:
    description: "Ensure syntactically correct Python code"
    validation_rules:
      ast_parsing: "Code must parse without syntax errors"
      indentation: "Consistent 4-space indentation"
      line_length: "Maximum 100 characters per line"
      encoding: "UTF-8 encoding for all Python files"

    common_issues:
      - "Missing colons in function/class definitions"
      - "Inconsistent indentation"
      - "Unclosed brackets/parentheses"
      - "Invalid escape sequences"

  # Import Organization and Quality
  import_quality:
    description: "Proper import organization and usage"
    validation_rules:
      import_order:
        1: "Standard library imports"
        2: "Third-party library imports"
        3: "Local application imports"

      import_style:
        - "Use absolute imports when possible"
        - "Avoid wildcard imports (from x import *)"
        - "Group related imports"
        - "Use aliases for long module names"

      unused_imports:
        detection: "Identify and flag unused imports"
        auto_removal: "Suggest removal of unused imports"

    validation_patterns:
      good_imports: |
        import asyncio
        import logging
        from typing import Dict, List, Optional

        import httpx
        from fastapi import FastAPI
        from pydantic import BaseModel

        from .config import Settings
        from .models import User

      bad_imports: |
        from fastapi import *  # Wildcard import
        import unused_module  # Never used
        from .models import User
        import asyncio  # Wrong order

  # Type Hint Quality
  type_hint_quality:
    description: "Comprehensive type hint validation"
    validation_rules:
      function_parameters:
        require_types: "All parameters must have type hints"
        avoid_any: "Discourage usage of Any type"
        use_specific_types: "Use specific types over generic ones"

      return_types:
        explicit_returns: "All functions must specify return types"
        async_functions: "Async functions must return Awaitable/Coroutine types"
        none_returns: "Functions returning None must specify -> None"

      variable_annotations:
        class_attributes: "Class attributes should have type hints"
        complex_variables: "Complex data structures should be annotated"

    validation_examples:
      good_typing: |
        async def get_user(user_id: int) -> Optional[Dict[str, Any]]:
            return await fetch_user_data(user_id)

        class UserService:
            http_client: httpx.AsyncClient
            base_url: str

      bad_typing: |
        async def get_user(user_id):  # Missing parameter type
            return await fetch_user_data(user_id)  # Missing return type

        def process_data(data: Any) -> Any:  # Overuse of Any

# Function and Method Quality
function_quality:
  # Function Design Principles
  function_design:
    description: "Well-designed function characteristics"
    validation_rules:
      function_length:
        max_lines: 50
        recommendation: "Functions should be focused and concise"

      parameter_count:
        max_parameters: 6
        suggestion: "Consider using dataclasses for many parameters"

      complexity:
        max_cyclomatic_complexity: 10
        measurement: "Count decision points (if, for, while, try)"

      single_responsibility:
        one_purpose: "Functions should do one thing well"
        descriptive_names: "Function names should describe their purpose"

  # Async/Await Quality
  async_quality:
    description: "Proper async/await usage"
    validation_rules:
      async_consistency:
        - "Async functions should await async operations"
        - "Don't mix sync and async inappropriately"
        - "Use async context managers for resources"

      async_patterns:
        good_patterns:
          - "async with httpx.AsyncClient() as client:"
          - "await asyncio.gather(task1, task2)"
          - "async for item in async_iterator:"

        bad_patterns:
          - "requests.get() in async function"  # Blocking call
          - "time.sleep() in async function"    # Blocking sleep
          - "Missing await on async functions"

# Error Handling Quality
error_handling:
  # Exception Handling Standards
  exception_handling:
    description: "Robust error handling patterns"
    validation_rules:
      specific_exceptions:
        - "Catch specific exceptions, not bare except:"
        - "Use appropriate exception types"
        - "Provide meaningful error messages"

      http_error_handling:
        required_catches:
          - "httpx.HTTPStatusError"
          - "httpx.RequestError"
          - "httpx.TimeoutError"

      database_error_handling:
        postgresql_errors: "Handle connection and query errors"
        mongodb_errors: "Handle document operation errors"

    validation_patterns:
      good_error_handling: |
        try:
            response = await client.get(url)
            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            logger.error("HTTP error", status=e.response.status_code)
            raise HTTPException(status_code=e.response.status_code)
        except httpx.RequestError as e:
            logger.error("Request error", error=str(e))
            raise HTTPException(status_code=503, detail="Service unavailable")

      bad_error_handling: |
        try:
            response = await client.get(url)
            return response.json()
        except:  # Too broad
            pass  # Silent failure

# Logging Quality
logging_quality:
  # Structured Logging Standards
  structured_logging:
    description: "Consistent structured logging practices"
    validation_rules:
      logger_setup:
        use_structlog: true
        logger_naming: "logger = structlog.get_logger(__name__)"
        configuration: "Proper structlog configuration"

      log_levels:
        debug: "Detailed diagnostic information"
        info: "General information about operation"
        warning: "Something unexpected but handled"
        error: "Error condition that needs attention"

      log_content:
        structured_data: "Use key-value pairs for context"
        avoid_sensitive_data: "Never log passwords or tokens"
        meaningful_messages: "Clear, actionable log messages"

    validation_examples:
      good_logging: |
        logger.info(
            "user_authenticated",
            user_id=user.id,
            request_id=request_id,
            duration_ms=duration
        )

        logger.error(
            "database_connection_failed",
            service="postgres",
            error=str(e),
            retry_attempt=3
        )

      bad_logging: |
        print("User logged in")  # Use logger, not print
        logger.info(f"Error: {e}")  # Not structured
        logger.debug(f"Password: {password}")  # Sensitive data

# Documentation Quality
documentation_quality:
  # Docstring Standards
  docstring_standards:
    description: "Comprehensive documentation requirements"
    validation_rules:
      function_docstrings:
        required_for: "All public functions and methods"
        format: "Google or NumPy style docstrings"
        content: "Description, Args, Returns, Raises"

      class_docstrings:
        required_for: "All public classes"
        content: "Class purpose, key attributes, usage examples"

      module_docstrings:
        required_for: "All modules"
        content: "Module purpose, main components"

    docstring_examples:
      good_docstring: |
        async def get_user_orders(user_id: int, limit: int = 10) -> List[Dict[str, Any]]:
            """Retrieve orders for a specific user.

            Args:
                user_id: The unique identifier for the user
                limit: Maximum number of orders to return (default: 10)

            Returns:
                List of order dictionaries containing order details

            Raises:
                HTTPException: If user not found or service unavailable
                ValueError: If user_id is invalid
            """

      bad_docstring: |
        def get_orders(user_id):
            """Gets orders"""  # Too brief, missing details

# Security Quality
security_quality:
  # Security Best Practices
  security_practices:
    description: "Security-focused code validation"
    validation_rules:
      sensitive_data:
        no_hardcoded_secrets: "No passwords, tokens, or keys in code"
        environment_variables: "Use env vars for sensitive configuration"
        secure_defaults: "Secure default values for all settings"

      input_validation:
        validate_all_inputs: "Validate all external inputs"
        pydantic_models: "Use Pydantic for request validation"
        sql_injection_prevention: "Use parameterized queries"

      authentication:
        proper_auth_handling: "Secure authentication implementation"
        token_validation: "Proper JWT token validation"
        permission_checks: "Authorization checks where needed"

    security_patterns:
      good_security: |
        # Environment variable usage
        database_url = os.getenv("DATABASE_URL")

        # Input validation
        class UserCreate(BaseModel):
            email: EmailStr
            password: str = Field(min_length=8)

        # Secure headers
        response.headers["X-Content-Type-Options"] = "nosniff"

      bad_security: |
        # Hardcoded secrets
        api_key = "sk-1234567890abcdef"

        # No input validation
        user_id = request.args.get("id")  # Could be SQL injection

# Performance Quality
performance_quality:
  # Performance Best Practices
  performance_practices:
    description: "Performance-oriented code validation"
    validation_rules:
      async_operations:
        non_blocking: "Use async/await for I/O operations"
        parallel_processing: "Use asyncio.gather for parallel tasks"
        proper_timeouts: "Set appropriate timeouts for HTTP requests"

      resource_management:
        connection_pooling: "Use connection pooling for databases"
        context_managers: "Proper resource cleanup with context managers"
        memory_efficiency: "Avoid memory leaks and excessive usage"

      caching:
        appropriate_caching: "Cache frequently accessed data"
        cache_invalidation: "Proper cache invalidation strategies"

    performance_examples:
      good_performance: |
        # Parallel HTTP requests
        async with httpx.AsyncClient() as client:
            tasks = [
                client.get(f"{postgres_url}/users/{user_id}"),
                client.get(f"{mongo_url}/analytics/users/{user_id}")
            ]
            results = await asyncio.gather(*tasks)

        # Proper resource management
        async with database.transaction():
            await update_user(user_data)

      bad_performance: |
        # Sequential HTTP requests (slow)
        user_data = await client.get(f"{postgres_url}/users/{user_id}")
        analytics = await client.get(f"{mongo_url}/analytics/users/{user_id}")

        # No connection pooling
        for item in items:
            connection = create_connection()
            process_item(item, connection)
            connection.close()

# Testing Quality
testing_quality:
  # Test Code Standards
  test_standards:
    description: "Quality standards for test code"
    validation_rules:
      test_coverage:
        minimum_coverage: "80% for critical paths"
        test_types: "Unit, integration, and contract tests"

      test_structure:
        descriptive_names: "Test function names describe what is tested"
        arrange_act_assert: "Clear test structure"
        isolated_tests: "Tests should not depend on each other"

      test_data:
        realistic_data: "Use realistic test data"
        data_factories: "Use factories for complex test objects"
        cleanup: "Proper test data cleanup"

# Code Quality Metrics
quality_metrics:
  # Measurable Quality Indicators
  metrics:
    complexity:
      cyclomatic_complexity: "Maximum 10 per function"
      cognitive_complexity: "Easy to understand and maintain"

    maintainability:
      function_length: "Average < 30 lines"
      class_length: "Average < 200 lines"
      parameter_count: "Average < 5 parameters"

    documentation:
      docstring_coverage: "90% for public APIs"
      comment_density: "Meaningful comments where needed"

    testing:
      test_coverage: "80% minimum, 95% for critical paths"
      test_ratio: "At least 1:1 test to production code"

# Validation Output Format
quality_output:
  quality_report:
    overall_score: "0-100 quality score"
    category_scores:
      syntax_quality: "0-100"
      type_hint_quality: "0-100"
      error_handling_quality: "0-100"
      logging_quality: "0-100"
      documentation_quality: "0-100"
      security_quality: "0-100"
      performance_quality: "0-100"

  issue_details:
    severity: "CRITICAL | HIGH | MEDIUM | LOW"
    category: "syntax | typing | error_handling | security | performance"
    file_location: "filename:line_number"
    description: "Issue description"
    suggestion: "How to fix the issue"

# Quality Improvement Suggestions
improvement_suggestions:
  automated_fixes:
    - "Add missing type hints"
    - "Organize imports"
    - "Remove unused imports"
    - "Fix indentation"
    - "Add docstrings"

  manual_improvements:
    - "Reduce function complexity"
    - "Improve error handling"
    - "Add security validations"
    - "Optimize performance patterns"
    - "Enhance test coverage"