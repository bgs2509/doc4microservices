# Architecture Compliance Validation Framework
# Validates generated code against Improved Hybrid Approach constraints

metadata:
  name: "Architecture Compliance Validator"
  version: "1.0.0"
  description: "Validates generated microservices code for architectural compliance"

# Core Architecture Rules Validation
architecture_validation:
  # Rule 1: HTTP-Only Data Access
  http_only_data_access:
    description: "Business services must access data only via HTTP APIs"
    validation_rules:
      prohibited_imports:
        - "import psycopg2"
        - "import asyncpg"
        - "import pymongo"
        - "import motor"
        - "from sqlalchemy import"
        - "from motor.motor_asyncio import"

      prohibited_patterns:
        - "direct database connection"
        - "DATABASE_URL in business services"
        - "create_engine"
        - "AsyncIOMotorClient"

      required_patterns:
        - "httpx.AsyncClient"
        - "HTTP requests to data services"
        - "postgres_service_url"
        - "mongo_service_url"

    validation_checks:
      business_services_check:
        files: ["api_service", "bot_service", "worker_service"]
        scan_for: "prohibited_imports + prohibited_patterns"
        ensure_present: "required_patterns"

      data_services_check:
        files: ["db_postgres_service", "db_mongo_service"]
        allow: "direct database connections"
        require: "database imports and connections"

  # Rule 2: Service Process Separation
  process_separation:
    description: "Each service type must run in separate processes"
    validation_rules:
      dockerfile_validation:
        each_service_must_have: "separate Dockerfile"
        no_shared_processes: true

      port_allocation:
        api_service: 8000
        db_postgres_service: 8001
        db_mongo_service: 8002
        bot_service: 8003
        worker_service: 8004

      docker_compose_validation:
        separate_containers: true
        no_shared_volumes_for_code: true
        proper_networking: true

  # Rule 3: Naming Convention Compliance
  naming_conventions:
    description: "Enforce underscore_only naming throughout codebase"
    validation_rules:
      service_names:
        pattern: "^[a-z][a-z0-9_]*_service$"
        examples: ["api_service", "user_management_service"]

      python_identifiers:
        variables: "^[a-z][a-z0-9_]*$"
        functions: "^[a-z][a-z0-9_]*$"
        classes: "^[A-Z][A-Za-z0-9]*$"  # PascalCase for classes
        modules: "^[a-z][a-z0-9_]*$"

      file_names:
        python_files: "^[a-z][a-z0-9_]*\\.py$"
        config_files: "^[a-z][a-z0-9_]*\\.(yml|yaml|json|env)$"

      prohibited_patterns:
        - "kebab-case in Python code"
        - "camelCase variables"
        - "hyphens in service names"

  # Rule 4: Python Version Compliance
  python_version:
    description: "All services must use Python 3.12+"
    validation_rules:
      dockerfile_check:
        base_image_pattern: "python:3\\.(1[2-9]|[2-9][0-9])"
        invalid_patterns: ["python:3.11", "python:3.10", "python:2"]

      requirements_check:
        python_requires: ">=3.12"
        incompatible_packages: ["python2", "legacy-packages"]

# Code Quality Validation
code_quality:
  # Type Hints Validation
  type_hints:
    description: "All functions must have complete type hints"
    validation_rules:
      function_signatures:
        require_parameter_types: true
        require_return_types: true
        allow_any_type: false  # Discourage Any usage

      import_requirements:
        - "from typing import"
        - "Optional, List, Dict, Union as needed"

    validation_patterns:
      valid_function: "async def function_name(param: Type) -> ReturnType:"
      invalid_function: "def function_name(param):"  # Missing types

  # Error Handling Validation
  error_handling:
    description: "Proper error handling patterns"
    validation_rules:
      http_requests:
        require_try_catch: true
        handle_http_errors: "httpx.HTTPStatusError"
        handle_connection_errors: "httpx.RequestError"

      database_operations:
        require_error_handling: true
        log_errors: true
        return_proper_http_status: true

  # Logging Validation
  logging_standards:
    description: "Structured logging requirements"
    validation_rules:
      logger_import: "import structlog"
      logger_usage: "logger = structlog.get_logger(__name__)"
      log_levels: ["debug", "info", "warning", "error"]
      structured_format: true

# Service-Specific Validation
service_validation:
  # FastAPI Service Validation
  fastapi_service:
    required_components:
      - "FastAPI app instance"
      - "Health check endpoints (/health, /ready)"
      - "CORS middleware"
      - "Request logging middleware"
      - "Dependency injection for data client"
      - "Error handling"

    required_patterns:
      - "httpx.AsyncClient for data service communication"
      - "Pydantic models for request/response"
      - "HTTP status code handling"
      - "lifespan context manager"

    prohibited_patterns:
      - "Direct database imports"
      - "Synchronous HTTP requests"
      - "Missing error handling"

  # Aiogram Service Validation
  aiogram_service:
    required_components:
      - "Bot and Dispatcher instances"
      - "Command handlers"
      - "Error handler"
      - "User management integration"
      - "Structured logging"

    required_patterns:
      - "HTTP-only data access"
      - "Async message handlers"
      - "Proper bot lifecycle management"

    prohibited_patterns:
      - "Direct database connections"
      - "Blocking operations in handlers"

  # Worker Service Validation
  worker_service:
    required_components:
      - "RabbitMQ connection setup"
      - "Event handlers"
      - "Scheduled task runner"
      - "Graceful shutdown handling"
      - "Background task decorators"

    required_patterns:
      - "asyncio.create_task for background tasks"
      - "Signal handlers for shutdown"
      - "HTTP client for data service communication"

    prohibited_patterns:
      - "Blocking operations without async"
      - "Missing shutdown handlers"

  # Data Service Validation
  data_service:
    required_components:
      - "Database connection management"
      - "Health check endpoints"
      - "CRUD operation endpoints"
      - "Bulk operation support"
      - "Error handling"

    required_patterns:
      - "Proper database client usage"
      - "Connection pooling"
      - "Transaction support (PostgreSQL)"
      - "Aggregation pipelines (MongoDB)"

# Integration Validation
integration_validation:
  # Service Communication
  service_communication:
    description: "Validate service-to-service communication patterns"
    validation_rules:
      http_endpoints:
        data_services_expose: ["health", "ready", "CRUD operations"]
        business_services_consume: "data service endpoints"

      rabbitmq_integration:
        event_publishing: "proper message format"
        event_consumption: "error handling and acknowledgment"
        queue_naming: "service.event_type pattern"

  # Configuration Validation
  configuration:
    description: "Validate service configuration"
    validation_rules:
      environment_variables:
        required_vars: ["SERVICE_PORT", "LOG_LEVEL"]
        data_service_urls: ["POSTGRES_SERVICE_URL", "MONGO_SERVICE_URL"]
        rabbitmq_config: ["RABBITMQ_URL"]

      settings_class:
        use_pydantic_settings: true
        environment_prefix: true
        validation: true

# Docker and Deployment Validation
deployment_validation:
  # Dockerfile Validation
  dockerfile:
    description: "Validate Dockerfile standards"
    validation_rules:
      base_image: "python:3.12+ official image"
      working_directory: "/app"
      dependency_installation: "requirements.txt with pip install"
      user_security: "non-root user for runtime"
      port_exposure: "EXPOSE correct port"

    required_commands:
      - "COPY requirements.txt"
      - "RUN pip install -r requirements.txt"
      - "COPY src/ ."
      - "CMD python main.py"

  # Docker Compose Validation
  docker_compose:
    description: "Validate docker-compose.yml configuration"
    validation_rules:
      service_definitions:
        all_services_present: true
        correct_ports: true
        proper_dependencies: true
        environment_variables: true

      networking:
        custom_network: true
        no_host_networking: true
        proper_service_discovery: true

# Validation Execution Framework
validation_execution:
  # Static Code Analysis
  static_analysis:
    tools:
      - name: "AST parsing"
        purpose: "Parse Python code structure"
        checks: ["imports", "function signatures", "class definitions"]

      - name: "Regular expressions"
        purpose: "Pattern matching in code"
        checks: ["naming conventions", "prohibited patterns"]

      - name: "File structure analysis"
        purpose: "Validate project structure"
        checks: ["required files", "directory organization"]

  # Configuration Analysis
  config_analysis:
    docker_files:
      - "Dockerfile validation"
      - "docker-compose.yml validation"
      - "requirements.txt validation"

    python_configs:
      - "pyproject.toml validation"
      - "settings.py validation"
      - "environment variable usage"

# Validation Output Format
validation_output:
  compliance_report:
    format: "JSON with hierarchical results"
    structure:
      overall_status: "COMPLIANT | NON_COMPLIANT | WARNINGS"
      rule_results:
        - rule_name: "string"
          status: "PASS | FAIL | WARNING"
          details: "string"
          affected_files: ["list"]

  error_details:
    violation_type: "string"
    file_location: "filename:line_number"
    description: "string"
    suggested_fix: "string"

  compliance_score:
    total_rules: "integer"
    passed_rules: "integer"
    failed_rules: "integer"
    warning_rules: "integer"
    compliance_percentage: "float"

# Auto-Fix Suggestions
auto_fix:
  naming_conventions:
    description: "Suggest corrections for naming violations"
    examples:
      "user-service" -> "user_service"
      "getUserData" -> "get_user_data"
      "UserAPI" -> "UserApi" (if class) or "user_api" (if variable)

  import_corrections:
    description: "Suggest proper imports for data access"
    examples:
      "import psycopg2" -> "import httpx  # Use HTTP client for data access"
      "from motor import motor_asyncio" -> "# Remove direct DB import, use HTTP"

  architecture_fixes:
    description: "Suggest architectural improvements"
    examples:
      direct_db_access: "Replace with HTTP request to data service"
      missing_health_check: "Add /health and /ready endpoints"
      missing_error_handling: "Add try-catch blocks for HTTP requests"

# Validation Examples
validation_examples:
  compliant_fastapi_service:
    status: "COMPLIANT"
    checks_passed:
      - "HTTP-only data access"
      - "Proper naming conventions"
      - "Complete type hints"
      - "Error handling present"
      - "Health checks implemented"

  non_compliant_service:
    status: "NON_COMPLIANT"
    violations:
      - rule: "http_only_data_access"
        issue: "Direct PostgreSQL import found"
        file: "api_service/main.py:5"
        fix: "Remove 'import psycopg2' and use httpx for HTTP requests"

      - rule: "naming_conventions"
        issue: "Hyphenated service name"
        file: "user-service/"
        fix: "Rename directory to 'user_service'"