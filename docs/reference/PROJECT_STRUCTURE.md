# Project Structure Guide

This document provides comprehensive guidance on organizing projects when using the microservices framework as a Git submodule.

## Framework Usage Patterns

This framework can be used in two ways:
- **Direct**: Working in this repository directly (use paths like `docs/`, `examples/`)
- **Submodule**: Added as `.framework/` submodule to your project (use paths like `.framework/docs/`, `.framework/examples/`)

## Recommended Project Structure

When you add this framework as a submodule, your project structure should follow this pattern:

```
my_awesome_app/                      # Your project repository
├── .framework/                      # Git submodule (this repository)
│   ├── docs/                       # Architecture rules and patterns
│   ├── ai_agents/                  # AI generators and validators
│   ├── examples/                   # Reference implementations
│   ├── use_cases/                  # Working applications
│   └── CLAUDE.md                   # AI instructions
├── README.md                        # Your project documentation
├── docker-compose.yml               # Your project infrastructure
├── .env.example                     # Your project configuration template (created by AI or manually)
├── pyproject.toml                   # Python dependencies and project config (generated by AI)
├── Makefile                         # Development automation commands (generated by AI)
├── .gitignore                       # Version control exclusions (generated by AI)
└── src/                            # Your application code
    ├── services/                   # Microservices
    │   ├── api_service/            # FastAPI REST API service
    │   │   ├── Dockerfile          # Service-specific container
    │   │   ├── main.py             # Service implementation
    │   │   ├── requirements.txt    # Service dependencies
    │   │   └── config.py           # Service configuration
    │   ├── bot_service/            # Aiogram Telegram bot service
    │   │   ├── Dockerfile
    │   │   ├── main.py
    │   │   ├── requirements.txt
    │   │   └── config.py
    │   ├── worker_service/         # AsyncIO background workers
    │   │   ├── Dockerfile
    │   │   ├── main.py
    │   │   ├── requirements.txt
    │   │   └── config.py
    │   ├── db_postgres_service/    # PostgreSQL data access service
    │   │   ├── Dockerfile
    │   │   ├── main.py
    │   │   └── requirements.txt
    │   └── db_mongo_service/       # MongoDB data access service
    │       ├── Dockerfile
    │       ├── main.py
    │       └── requirements.txt
    ├── shared/                     # Shared components
    │   ├── dtos.py                # Data transfer objects
    │   ├── events.py              # Event schemas
    │   └── utils.py               # Common utilities
    ├── config/                     # Configuration management
    │   ├── settings.py            # Centralized settings
    │   └── logging.py             # Logging configuration
    └── tests/                     # Test suites
        ├── unit/                  # Unit tests per service
        │   ├── test_api_service.py
        │   ├── test_bot_service.py
        │   └── test_workers.py
        ├── integration/           # Integration tests
        │   ├── test_service_communication.py
        │   └── test_data_flows.py
        └── conftest.py            # Test configuration
```

## Directory Structure Explanation

### Framework Directory (`.framework/`)
- **Immutable**: Never modify framework content when used as submodule
- **Patterns**: Contains architecture rules, AI agents, and reference implementations
- **Updates**: Use `git submodule update --remote .framework` to get latest improvements

### Root-Level Configuration
- **`pyproject.toml`**: Python dependencies and project metadata (generated by AI)
- **`Makefile`**: Development automation commands (build, test, deploy commands)
- **`.gitignore`**: Version control exclusions (generated by AI)
- **`.env.example`**: Environment configuration template with all variables

### Application Code (`src/`)
- **Your Code**: All your business logic and application-specific implementations
- **Services**: Individual microservices following the Improved Hybrid Approach
- **Shared**: Common utilities and data structures used across services
- **Config**: Centralized configuration and environment management
- **Tests**: Comprehensive test suites for all services

### Service Types

#### Data Services
- **`db_postgres_service/`**: PostgreSQL data access service (Port: 8001)
- **`db_mongo_service/`**: MongoDB data access service (Port: 8002)
- **Purpose**: Centralized database operations, no business logic

#### Business Services
- **`api_service/`**: FastAPI REST API service (Port: 8000)
- **`bot_service/`**: Aiogram Telegram bot service
- **`worker_service/`**: AsyncIO background workers
- **Purpose**: Business logic only, HTTP-only data access

### Service File Structure
Each service contains:
- **`Dockerfile`**: Service-specific container configuration
- **`main.py`**: Service implementation
- **`requirements.txt`**: Service dependencies
- **`config.py`**: Service-specific configuration

### Test Organization
- **`tests/unit/`**: Individual test files per service (e.g., `test_api_service.py`)
- **`tests/integration/`**: Cross-service communication tests
- **`conftest.py`**: Centralized test fixtures and configuration

## Docker Compose Organization

### Single Root Compose Setup (Recommended)
Use one main `docker-compose.yml` in the project root, not individual compose files per service.

**Benefits:**
- **Data Service Isolation**: Centralized database expertise and optimization
- **Business Logic Focus**: Services contain only business logic, no database concerns
- **Shared Infrastructure**: Redis, RabbitMQ, observability stack shared across all services
- **Proper Service Networking**: HTTP communication between business and data services
- **Unified Environment**: Single command deployment with proper dependency management

## Framework Management

### Submodule Operations
```bash
# Update framework to latest version
git submodule update --remote .framework
git add .framework && git commit -m "Update framework"

# Clone project with framework
git clone --recursive <your-project-repo>

# If you forgot --recursive
git submodule init && git submodule update
```

### Development Workflow
1. **Add framework as submodule** to your project
2. **Generate application code** in `src/` using AI or manual development
3. **Follow framework patterns** from `.framework/docs/` and `.framework/examples/`
4. **Never modify** `.framework/` content
5. **Update framework** periodically with `git submodule update --remote`

## Quick Setup Guide

```bash
# 1. Create your project
mkdir my_awesome_app && cd my_awesome_app && git init

# 2. Add framework as submodule
git submodule add <framework-repo-url> .framework
git submodule init && git submodule update

# 3. Generate application with AI (AI reads framework patterns)
# Ask AI: "Create [your app] using .framework/ patterns"

# 4. Deploy ready application
docker-compose up -d
```

## Architecture Compliance

When organizing your project:

### Critical Constraints
- ❌ **PROHIBITED**: Direct database connections in business services
- ❌ **PROHIBITED**: Running multiple event loop managers in same process
- ⚠️ **MANDATORY**: Python 3.12+ for all services
- ⚠️ **MANDATORY**: Underscore-only naming convention (no hyphens)

### Service Communication
- **Business → Data**: HTTP APIs only
- **Inter-service**: RabbitMQ for events
- **Service Isolation**: Each service type in separate containers

### Documentation References
- **Architecture Details**: `.framework/docs/guides/ARCHITECTURE_GUIDE.md`
- **Development Commands**: `.framework/docs/guides/DEVELOPMENT_COMMANDS.md`
- **Technology Stack**: `.framework/docs/reference/tech_stack.md`
- **Working Examples**: `.framework/examples/index.md`