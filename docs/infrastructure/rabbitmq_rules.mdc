---
description: RabbitMQ standard for Python microservices; defines rules for asynchronous queue interaction using aio-pika, Pydantic, and logging standards.
globs: ["src/**/*.py"]
alwaysApply: true
---

### Title
RabbitMQ Rules (Python, aio-pika, DDD/Hex)

### Version and Date
- Version: v2.0.0
- Updated: 2025-09-19
- Owner: rules/architecture

### Purpose
Define a single, verifiable standard for working with RabbitMQ in Python using `aio-pika`, ensuring reliability, tracing (Request ID and Trace Context), idempotency, contract standardization, and comprehensive testing.

### Scope
- Covers: connection management, queue/exchange declaration, message publishing/consuming, DTO contracts, error handling, idempotency, tracing, FastAPI integration, Aiogram integration, asyncio integration, and testing requirements.
- Excludes: general microservice practices (see `ms_best_practices_rules.mdc`) and logging rules (see `logging_rules.mdc`).

### Terms and Definitions
- **DTO**: Pydantic `BaseModel` for messages, providing validation and serialization.
- **Request ID**: cross-cutting request identifier for full tracing.
- **Idempotency**: property of a consumer to safely handle the same message multiple times without side effects.
- **Trace Context**: W3C Trace Context header for distributed tracing.
- **Test Fixtures**: Reusable test components for RabbitMQ connections, exchanges, and queues.
- **FastAPI Integration**: RabbitMQ client integration within FastAPI event loop for HTTP API services.
- **Aiogram Integration**: RabbitMQ client integration within Aiogram event loop for Telegram bot services.
- **Asyncio Integration**: RabbitMQ client integration within asyncio.run(main()) event loop for worker services.

### Rules
1) **Connection Management**
   - **MUST:** Use `aio-pika.connect_robust()` for reliable connections.
   - **MUST:** Establish connection and channel once at application startup (in `lifespan`, `startup` lifecycle, or `main()` function) and close on shutdown.
   - **SHOULD:** Avoid creating new connections and channels on every call.

2) **FastAPI Integration**
   - **MUST:** For FastAPI services, initialize RabbitMQ client once in the `lifespan` function and store it in application state using `app.state.rabbitmq = rabbitmq_client`.
   - **MUST:** Pass RabbitMQ client as dependency to handlers via dependency injection: `async def handler(rabbitmq: RabbitMQClient = Depends(get_rabbitmq))`.
   - **MUST NOT:** Create new RabbitMQ connections on every operation; reuse the same client instance.
   - **MUST:** Use `async with` for managing RabbitMQ connection lifecycle within the FastAPI event loop.
   - **MUST:** Ensure RabbitMQ operations are fully async and compatible with FastAPI's event loop.
   - **MUST NOT:** Use `asyncio.run()` or create separate event loops in RabbitMQ operations when used with FastAPI.
   - **SHOULD:** Implement proper error handling and reconnection logic for RabbitMQ connections.

3) **Aiogram Integration**
   - **MUST:** For Aiogram services, initialize RabbitMQ client once at application startup and register as dependency using `dp.startup.register(lambda: {"rabbitmq": rabbitmq_client})`.
   - **MUST:** Pass RabbitMQ client as dependency to handlers via dependency injection: `async def handler(message: Message, rabbitmq: RabbitMQClient)`.
   - **MUST NOT:** Create new RabbitMQ connections on every operation; reuse the same client instance.
   - **MUST:** Use `async with` for managing RabbitMQ connection lifecycle within the Aiogram event loop.
   - **MUST:** Ensure RabbitMQ operations are fully async and compatible with Aiogram's event loop.
   - **MUST NOT:** Use `asyncio.run()` or create separate event loops in RabbitMQ operations when used with Aiogram.
   - **SHOULD:** Implement proper error handling and reconnection logic for RabbitMQ connections.

4) **Asyncio Integration**
   - **MUST:** For asyncio.run(main()) services, initialize RabbitMQ client once in the `main()` function and store it in a global context or dependency container.
   - **MUST:** Pass RabbitMQ client as dependency to worker functions and tasks.
   - **MUST NOT:** Create new RabbitMQ connections on every operation; reuse the same client instance.
   - **MUST:** Use `async with` for managing RabbitMQ connection lifecycle within the asyncio event loop.
   - **MUST:** Ensure RabbitMQ operations are fully async and compatible with asyncio event loop.
   - **SHOULD:** Implement proper error handling and reconnection logic for RabbitMQ connections.

5) **Resource Declaration**
   - **MUST:** Declare `topic exchange` `photos.events` in both microservices: publishing (`zd_tg_photo_upload_api`) and consuming (`zd_file_handling`, `zd_pg_file_record`).
   - **MUST:** Declare queues with specified routing key, e.g., `q.file_handling.photo_received` for `zd_file_handling` and `q.catalog.photo_processed` for `zd_pg_file_record`.
   - **SHOULD:** Use `durable=True` for queues and exchanges so they survive broker restarts.

6) **Contracts and Payload**
   - **MUST:** Serialize DTO to JSON and encode to UTF-8 before sending.
   - **MUST:** Use Pydantic `BaseModel` for `PhotoReceivedPayloadDTO` and `PhotoProcessedPayloadDTO` for strict data validation.
   - **SHOULD:** Set `content_type='application/json'` and `delivery_mode=2` (persistent) when publishing.

7) **Tracing and Idempotency**
   - **MUST:** Add `Request ID` to message header (`x-request-id`) before publishing.
   - **MUST:** Add W3C Trace Context header (`traceparent`) before publishing when available from OpenTelemetry span context.
   - **MUST:** Implement idempotency logic in consumers using `Redis` to check `Request ID` uniqueness.
   - **SHOULD:** Use `request_id` in every call to `logger.info()`, `logger.error()`, etc.

8) **Message Processing and Error Handling**
   - **MUST:** Process messages asynchronously using `async with channel.consume(...)`.
   - **MUST:** Send `ack` after successful processing and `nack` with `requeue=False` for unrecoverable errors.
   - **SHOULD:** Log `ack/nack/requeue` and errors using appropriate keys (e.g., `status=ack`, `error=invalid_payload`).
   - **SHOULD:** Implement DLQ (Dead-Letter Queue) for handling messages that cannot be processed after multiple attempts.

9) **Monitoring**
   - **MUST:** Collect metrics such as processing time, publish/consume counts, `ack/nack`, retry counts, and message sizes.

10) **Testing Requirements**
   - **MUST:** Provide automated tests with `pytest` for all RabbitMQ operations; aim for high coverage; critical paths SHOULD reach 100%.
   - **MUST:** Use `testcontainers` for RabbitMQ integration tests to ensure realistic testing environment.
   - **MUST:** Provide test fixtures for RabbitMQ connections, exchanges, and queues that can be reused across test modules.
   - **MUST:** Test both publishing and consuming operations with proper DTO validation and error handling.
   - **MUST:** Test idempotency logic using Redis test containers or in-memory Redis instances.
   - **MUST:** Test message tracing with `x-request-id` and `traceparent` headers.
   - **MUST:** Test error scenarios including connection failures, message processing errors, and DLQ handling.
   - **MUST:** For FastAPI integration tests, use existing event loop from `pytest-asyncio` without creating new `asyncio.run()` calls.
   - **MUST:** For Aiogram integration tests, use existing event loop from `pytest-asyncio` without creating new `asyncio.run()` calls.
   - **MUST:** For asyncio integration tests, use existing event loop from `pytest-asyncio` without creating new `asyncio.run()` calls.
   - **SHOULD:** Use async test patterns with `pytest-asyncio` for all RabbitMQ operations.
   - **SHOULD:** Provide data factories for creating test DTOs and message payloads.
   - **SHOULD:** Test message ordering and delivery guarantees where applicable.
   - **SHOULD:** Mock external dependencies (Redis, OpenTelemetry) in unit tests while using real RabbitMQ in integration tests.

### Priorities and Compatibility
- Depends on: `../architecture/ms_best_practices_rules.mdc` (system-wide standard), `../observability/logging_rules.mdc` (observability), `../services/fastapi_rules.mdc` (FastAPI integration), `../services/aiogram_rules.mdc` (Aiogram integration), `../services/asyncio_rules.mdc` (asyncio integration).
- Does not duplicate: general microservice rules (see `../architecture/ms_best_practices_rules.mdc`) and logging rules (see `../observability/logging_rules.mdc`).
- Conflicts: none.

### Examples
```python
# Example RabbitMQ client for asyncio.run(main()), FastAPI integration
import asyncio
from aio_pika import connect_robust, Exchange, Message, DeliveryMode
from aio_pika.abc import AbstractIncomingMessage
from src.schemas.events import PhotoReceivedPayloadDTO, PhotoProcessedPayloadDTO
from src.core.logging import logger, generate_request_id, get_current_request_id
import json

class RabbitMQClient:
    def __init__(self, connection_url: str):
        self.connection_url = connection_url
        self.connection = None
        self.channel = None
        self.exchange = None

    async def connect(self) -> None:
        """Initialize RabbitMQ connection within asyncio, FastAPI event loop."""
        self.connection = await connect_robust(self.connection_url)
        self.channel = await self.connection.channel()

        # Declare exchange
        self.exchange = await self.channel.declare_exchange(
            "photos.events",
            type="topic",
            durable=True
        )
        logger.info("rabbitmq_connected exchange=photos.events")

    async def publish_photo_received(self, payload: PhotoReceivedPayloadDTO, request_id: str) -> None:
        """Publish photo received event with Request ID tracing."""
        body = json.dumps(payload.model_dump()).encode()
        headers = {'x-request-id': request_id}

        message = Message(
            body=body,
            content_type='application/json',
            delivery_mode=DeliveryMode.PERSISTENT,
            headers=headers
        )

        await self.exchange.publish(message, routing_key='photo.received')
        logger.info(f"rabbitmq_published rk=photo.received request_id={request_id}")

    async def start_consuming(self) -> None:
        """Start consuming messages from queues."""
        # Declare and bind queues
        queue = await self.channel.declare_queue("q.file_handling.photo_received", durable=True)
        await queue.bind(self.exchange, "photo.received")

        async with queue.iterator() as queue_iter:
            async for message in queue_iter:
                await self.process_message(message)

    async def process_message(self, message: AbstractIncomingMessage) -> None:
        """Process incoming message with proper error handling."""
        request_id = message.headers.get('x-request-id', 'unknown')

        try:
            async with message.process():
                payload = PhotoReceivedPayloadDTO.model_validate_json(message.body)
                logger.info(f"rabbitmq_message_processed request_id={request_id}")

                # Process message logic here
                await self.handle_photo_received(payload, request_id)

        except Exception as e:
            logger.exception(f"rabbitmq_message_failed request_id={request_id} error={str(e)}")
            # Message will be nacked automatically by message.process()

    async def handle_photo_received(self, payload: PhotoReceivedPayloadDTO, request_id: str) -> None:
        """Handle photo received event."""
        # Implementation depends on business logic
        logger.info(f"photo_handled file_id={payload.file_id} request_id={request_id}")

    async def close(self) -> None:
        """Close RabbitMQ connection."""
        if self.connection and not self.connection.is_closed:
            await self.connection.close()
            logger.info("rabbitmq_disconnected")
```

```python
# Example FastAPI integration with RabbitMQ as dependency
from contextlib import asynccontextmanager
from fastapi import FastAPI, Depends
from fastapi.responses import ORJSONResponse
from src.adapters.rabbitmq.photo_event_publisher import RabbitMQClient

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Initialize RabbitMQ client
    rabbitmq_client = RabbitMQClient("amqp://guest:guest@localhost:5672/")
    await rabbitmq_client.connect()
    app.state.rabbitmq = rabbitmq_client

    yield

    # Graceful shutdown
    await rabbitmq_client.close()

# RabbitMQ dependency injection
async def get_rabbitmq(app: FastAPI) -> RabbitMQClient:
    return app.state.rabbitmq

app = FastAPI(lifespan=lifespan, default_response_class=ORJSONResponse)

# Example router with RabbitMQ dependency
from fastapi import APIRouter, Depends, status
from src.schemas.events import PhotoReceivedPayloadDTO

router = APIRouter()

@router.post(
    "/upload_photo",
    response_model=dict,
    status_code=status.HTTP_200_OK,
    summary="Upload photo",
    description="Upload photo and publish event to RabbitMQ.",
)
async def upload_photo(
    payload: PhotoReceivedPayloadDTO,
    rabbitmq: RabbitMQClient = Depends(get_rabbitmq),
) -> dict:
    # Publish event to RabbitMQ
    request_id = generate_request_id("photo_upload")
    await rabbitmq.publish_photo_received(payload, request_id)

    return {"status": "uploaded", "request_id": request_id}
```

```python
# Example Aiogram integration with RabbitMQ as dependency
import asyncio
from aiogram import Bot, Dispatcher, Router
from aiogram.types import Message
from src.adapters.rabbitmq.photo_event_publisher import RabbitMQClient
from src.core.logging import generate_request_id, set_request_id, logger

async def main():
    bot = Bot(token="TOKEN")
    dp = Dispatcher()
    router = Router()

    # Initialize RabbitMQ client
    rabbitmq_client = RabbitMQClient("amqp://guest:guest@localhost:5672/")
    await rabbitmq_client.connect()

    # Register RabbitMQ as dependency in Aiogram
    dp.startup.register(lambda: {"rabbitmq": rabbitmq_client})

    # Register handlers
    router.message.register(handle_photo, content_types=["photo"])
    dp.include_router(router)

    # Start polling in single event loop
    await dp.start_polling(bot)

async def handle_photo(message: Message, rabbitmq: RabbitMQClient):
    """Handle photo message with RabbitMQ dependency injection."""
    request_id = generate_request_id("tg", user_id=message.from_user.id, chat_id=message.chat.id)
    set_request_id(request_id)

    # Process photo and publish event
    payload = PhotoReceivedPayloadDTO(
        file_path="temp_file_path",
        user_id=message.from_user.id,
        chat_id=message.chat.id
    )

    # Publish event to RabbitMQ
    await rabbitmq.publish_photo_received(payload, request_id)
    logger.info(f"photo_processed request_id={request_id}")

if __name__ == "__main__":
    asyncio.run(main())
```

```python
# Example main file for asyncio service with RabbitMQ
import asyncio
import signal
from contextlib import suppress
from src.core.logging import setup_logging, logger, generate_request_id, set_request_id
from src.adapters.rabbitmq.photo_event_publisher import RabbitMQClient

# Global RabbitMQ client
rabbitmq_client: RabbitMQClient | None = None

async def main():
    global rabbitmq_client

    # Setup logging
    setup_logging()
    request_id = generate_request_id("worker_startup")
    set_request_id(request_id)
    logger.info("worker_startup service=file_handling_worker")

    # Initialize RabbitMQ
    rabbitmq_client = RabbitMQClient("amqp://guest:guest@localhost:5672/")
    await rabbitmq_client.connect()

    # Setup signal handlers
    loop = asyncio.get_event_loop()
    consumer_task = None

    def signal_handler(signum):
        logger.info(f"signal_received signal={signum}")
        if consumer_task:
            consumer_task.cancel()

    loop.add_signal_handler(signal.SIGINT, lambda: signal_handler(signal.SIGINT))
    loop.add_signal_handler(signal.SIGTERM, lambda: signal_handler(signal.SIGTERM))

    # Start consuming
    consumer_task = asyncio.create_task(rabbitmq_client.start_consuming())

    try:
        await consumer_task
    except asyncio.CancelledError:
        logger.info("worker_shutdown_requested reason=signal")
    finally:
        if rabbitmq_client:
            await rabbitmq_client.close()
        logger.info("worker_shutdown_completed")

if __name__ == "__main__":
    with suppress(asyncio.CancelledError):
        asyncio.run(main())
```

```python
# Example test fixtures for RabbitMQ testing with FastAPI, Aiogram, and Asyncio compatibility
import pytest
import pytest_asyncio
from aio_pika import connect_robust, ExchangeType
from testcontainers.rabbitmq import RabbitMqContainer
from fastapi.testclient import TestClient
from aiogram import Bot, Dispatcher
from aiogram.test import make_mocked_bot
from src.adapters.rabbitmq.photo_event_publisher import RabbitMQClient

@pytest.fixture(scope="session")
def rabbitmq_container():
    with RabbitMqContainer("rabbitmq:3.13-management") as container:
        yield container

@pytest.fixture
async def rabbitmq_client(rabbitmq_container):
    """RabbitMQ client for testing - uses existing event loop."""
    client = RabbitMQClient(rabbitmq_container.get_connection_url())
    await client.connect()
    yield client
    await client.close()

@pytest.fixture
async def test_exchange(rabbitmq_client):
    """Test exchange for publishing messages."""
    return rabbitmq_client.exchange

@pytest.fixture
async def test_queue(rabbitmq_client):
    """Test queue for consuming messages."""
    queue = await rabbitmq_client.channel.declare_queue("test.queue", durable=True)
    await queue.bind(rabbitmq_client.exchange, "test.routing.key")
    yield queue
    await queue.delete()

# FastAPI test fixtures
@pytest.fixture
async def test_app(rabbitmq_client):
    """FastAPI test app with RabbitMQ dependency override."""
    from src.main import app, get_rabbitmq

    app.dependency_overrides[get_rabbitmq] = lambda: rabbitmq_client
    yield app
    app.dependency_overrides.clear()

@pytest.fixture
def client(test_app):
    """Test client for FastAPI app."""
    return TestClient(test_app)

# Aiogram test fixtures
@pytest.fixture
async def aiogram_dp_with_rabbitmq(rabbitmq_client):
    """Aiogram dispatcher with RabbitMQ dependency for testing."""
    dp = Dispatcher()
    dp.startup.register(lambda: {"rabbitmq": rabbitmq_client})
    yield dp

@pytest.fixture
async def mocked_bot():
    """Mocked Aiogram bot for testing."""
    return make_mocked_bot()

# Example FastAPI integration test
@pytest.mark.asyncio
async def test_photo_upload_with_rabbitmq_integration(client, rabbitmq_client):
    """Test photo upload endpoint with RabbitMQ integration."""
    # Arrange
    payload = {
        "file_id": "test_file_123",
        "user_id": 456,
        "chat_id": 789
    }

    # Act
    response = client.post("/api/v1/upload_photo", json=payload)

    # Assert
    assert response.status_code == 200
    data = response.json()
    assert "status" in data
    assert "request_id" in data

# Example Aiogram integration test
@pytest.mark.asyncio
async def test_aiogram_photo_handling_with_rabbitmq(aiogram_dp_with_rabbitmq, mocked_bot):
    """Test Aiogram photo handling with RabbitMQ integration."""
    from aiogram.types import Message, User, Chat, PhotoSize

    # Arrange
    user = User(id=123, is_bot=False, first_name="Test")
    chat = Chat(id=456, type="private")
    photo = PhotoSize(file_id="test_file_123", file_unique_id="unique_123", width=100, height=100, file_size=1024)

    message = Message(
        message_id=1,
        from_user=user,
        chat=chat,
        date=1234567890,
        photo=[photo]
    )

    # Act - Process message through handler
    handler = aiogram_dp_with_rabbitmq._handlers[0].callback
    await handler(message, rabbitmq=aiogram_dp_with_rabbitmq._data["rabbitmq"])

    # Assert - Check RabbitMQ operations (implementation depends on RabbitMQClient)
    # This would typically involve checking a test queue or using a mock

# Example asyncio integration test
@pytest.mark.asyncio
async def test_photo_received_publishing(test_exchange, test_queue):
    # Arrange
    payload = PhotoReceivedPayloadDTO(
        file_id="test_file_123",
        user_id=456,
        chat_id=789
    )
    request_id = "test_req_123"

    # Act
    await rabbitmq_client.publish_photo_received(payload, request_id)

    # Assert
    message = await test_queue.get(timeout=5)
    assert message is not None
    assert message.headers["x-request-id"] == request_id

    received_payload = PhotoReceivedPayloadDTO.model_validate_json(message.body)
    assert received_payload.file_id == payload.file_id
    assert received_payload.user_id == payload.user_id
    assert received_payload.chat_id == payload.chat_id

    await message.ack()

@pytest.mark.asyncio
async def test_rabbitmq_connection_lifecycle(rabbitmq_container):
    """Test RabbitMQ connection lifecycle within event loop."""
    # Arrange
    client = RabbitMQClient(rabbitmq_container.get_connection_url())

    # Act - Connect
    await client.connect()
    assert client.connection is not None
    assert not client.connection.is_closed

    # Act - Close
    await client.close()
    assert client.connection.is_closed
```

### Verification
- How to verify:
  - Check usage of `aio-pika.connect_robust()` for connections.
  - Ensure `photos.events` exchange is declared in all microservices.
  - Verify presence of `x-request-id` in message headers.
  - Ensure use of Pydantic DTOs for message validation.
  - Check idempotency implementation via Redis.
  - Verify presence of `traceparent` in message headers when OpenTelemetry trace context is available.
  - For FastAPI services, verify RabbitMQ client is registered in application state and accessed via dependency injection.
  - For Aiogram services, verify RabbitMQ client is registered as dependency using `dp.startup.register()`.
  - For asyncio services, verify RabbitMQ client is initialized once in `main()` function and passed as dependency.
  - Ensure no `asyncio.run()` calls in RabbitMQ operations when used with FastAPI, Aiogram, or asyncio services.
  - Run RabbitMQ tests with `pytest tests/integration/test_rabbitmq_integration.py`.
  - Verify test coverage for RabbitMQ operations reaches 100% for critical paths.
  - Check that testcontainers are used for integration tests.
  - Ensure test fixtures work within existing event loop without creating conflicts.
- Success criteria:
  - All connections use `connect_robust()`; exchanges and queues are declared; Request ID is passed; DTOs are validated; idempotency is implemented; FastAPI, Aiogram, and asyncio integration working; comprehensive test coverage achieved.

### Changes
- 2025-01-27 v1.5.0: Added Aiogram integration rules for RabbitMQ, dependency injection patterns, event loop compatibility requirements, and updated test fixtures for Aiogram compatibility alongside FastAPI and asyncio.
- 2025-01-27 v1.4.0: Added FastAPI integration rules for RabbitMQ, dependency injection patterns, event loop compatibility requirements, and updated test fixtures for both FastAPI and asyncio compatibility.
- 2025-01-27 v1.3.0: Added asyncio integration rules for RabbitMQ, dependency injection patterns, event loop compatibility requirements, and updated test fixtures for asyncio compatibility.
- 2025-09-05 v1.2.0: Added comprehensive testing requirements aligned with FastAPI testing standards, including testcontainers, async test patterns, fixtures, and 100% coverage requirements for critical paths.
- 2025-09-05 v1.1.0: Updated RabbitMQ rules to include `traceparent` header propagation alongside `x-request-id` to resolve the conflict with logging rules.
- 2025-09-05 v1.0.0: Initial RabbitMQ rules for Python microservices with aio-pika, DDD/Hex architecture.
