---
description: Testing standards and patterns for microservices with 100% coverage requirement
globs: ["**/tests/**/*.py", "**/test_*.py", "**/*_test.py"]
alwaysApply: false
---

# Testing Standards for Microservices

## Testing Philosophy
- Achieve 100% test coverage for all new code (critical paths MUST reach 100%)
- Use real database instances instead of mocks for integration tests
- Write tests before or alongside implementation (TDD approach)
- Test business logic, API endpoints, and database interactions
- Use pytest with async support for all async services (FastAPI, Aiogram, AsyncIO)
- Use testcontainers for stateful dependencies (PostgreSQL, RabbitMQ, Redis, ChromaDB) in integration tests
- Ensure single event loop compatibility for all async operations

## Test Structure
```
tests/
├── unit/
│   ├── test_services/
│   ├── test_models/
│   └── test_utils/
├── integration/
│   ├── test_api/
│   ├── test_database/
│   └── test_messaging/
├── e2e/
│   └── test_workflows/
├── conftest.py
└── fixtures/
```

## Unit Testing Patterns
```python
# tests/unit/test_user_service.py
import pytest
from unittest.mock import AsyncMock, patch
from app.services.user_service import UserService
from app.schemas import UserCreate
from app.models import User

@pytest.fixture
def mock_db():
    return AsyncMock()

@pytest.fixture
def user_service(mock_db):
    return UserService(mock_db)

@pytest.mark.asyncio
async def test_create_user_success(user_service, mock_db):
    """Test successful user creation."""
    # Arrange
    user_data = UserCreate(
        email="test@example.com",
        full_name="Test User",
        password="secure_password"
    )
    expected_user = User(id=1, email=user_data.email, full_name=user_data.full_name)
    mock_db.add.return_value = None
    mock_db.commit.return_value = None
    mock_db.refresh.return_value = None
    
    # Act
    result = await user_service.create_user(user_data)
    
    # Assert
    assert result.email == user_data.email
    assert result.full_name == user_data.full_name
    mock_db.add.assert_called_once()
    mock_db.commit.assert_called_once()
    mock_db.refresh.assert_called_once()

@pytest.mark.asyncio
async def test_create_user_duplicate_email(user_service, mock_db):
    """Test user creation with duplicate email."""
    # Arrange
    user_data = UserCreate(
        email="existing@example.com",
        full_name="Test User",
        password="secure_password"
    )
    mock_db.commit.side_effect = IntegrityError("duplicate email", None, None)
    
    # Act & Assert
    with pytest.raises(DuplicateUserError):
        await user_service.create_user(user_data)
```

## Integration Testing with Real Database
```python
# tests/integration/test_user_api.py
import pytest
from httpx import AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession
from app.main import app
from app.database import get_database
from app.models import User

@pytest.fixture
async def test_db():
    """Create test database session."""
    # Use real test database instance
    async with get_database() as session:
        yield session

@pytest.fixture
async def client(test_db):
    """Create test client with database dependency override."""
    def override_get_db():
        return test_db
    
    app.dependency_overrides[get_database] = override_get_db
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac
    app.dependency_overrides.clear()

@pytest.mark.asyncio
async def test_create_user_integration(client: AsyncClient, test_db: AsyncSession):
    """Test user creation through API with real database."""
    # Arrange
    user_data = {
        "email": "integration@example.com",
        "full_name": "Integration Test User",
        "password": "secure_password"
    }
    
    # Act
    response = await client.post("/users/", json=user_data)
    
    # Assert
    assert response.status_code == 201
    data = response.json()
    assert data["email"] == user_data["email"]
    assert data["full_name"] == user_data["full_name"]
    assert "id" in data
    
    # Verify in database
    result = await test_db.execute(
        select(User).where(User.email == user_data["email"])
    )
    user = result.scalar_one_or_none()
    assert user is not None
    assert user.email == user_data["email"]

@pytest.mark.asyncio
async def test_get_user_integration(client: AsyncClient, test_db: AsyncSession):
    """Test getting user through API with real database."""
    # Arrange - Create user in database
    user = User(
        email="get@example.com",
        full_name="Get Test User",
        password_hash="hashed_password"
    )
    test_db.add(user)
    await test_db.commit()
    await test_db.refresh(user)
    
    # Act
    response = await client.get(f"/users/{user.id}")
    
    # Assert
    assert response.status_code == 200
    data = response.json()
    assert data["id"] == user.id
    assert data["email"] == user.email
```

## Database Testing Patterns
```python
# tests/integration/test_database.py
import pytest
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import get_database
from app.models import User

@pytest.fixture
async def db_session():
    """Create isolated database session for testing."""
    async with get_database() as session:
        # Start transaction
        transaction = await session.begin()
        yield session
        # Rollback transaction to clean up
        await transaction.rollback()

@pytest.mark.asyncio
async def test_user_crud_operations(db_session: AsyncSession):
    """Test CRUD operations with real database."""
    # Create
    user = User(
        email="crud@example.com",
        full_name="CRUD Test User",
        password_hash="hashed_password"
    )
    db_session.add(user)
    await db_session.commit()
    await db_session.refresh(user)
    
    # Read
    result = await db_session.execute(
        select(User).where(User.id == user.id)
    )
    found_user = result.scalar_one_or_none()
    assert found_user is not None
    assert found_user.email == user.email
    
    # Update
    found_user.full_name = "Updated Name"
    await db_session.commit()
    await db_session.refresh(found_user)
    assert found_user.full_name == "Updated Name"
    
    # Delete
    await db_session.delete(found_user)
    await db_session.commit()
    
    # Verify deletion
    result = await db_session.execute(
        select(User).where(User.id == user.id)
    )
    assert result.scalar_one_or_none() is None
```

## Messaging Testing
```python
# tests/integration/test_messaging.py
import pytest
from unittest.mock import AsyncMock
from app.messaging import MessageProducer, MessageConsumer

@pytest.fixture
async def message_producer():
    """Create message producer for testing."""
    return MessageProducer()

@pytest.fixture
async def message_consumer():
    """Create message consumer for testing."""
    return MessageConsumer()

@pytest.mark.asyncio
async def test_message_publishing(message_producer):
    """Test message publishing with real RabbitMQ."""
    message = {
        "event_type": "user_created",
        "user_id": 123,
        "email": "test@example.com"
    }
    
    result = await message_producer.publish("user.events", message)
    assert result is True

@pytest.mark.asyncio
async def test_message_consuming(message_consumer):
    """Test message consuming with real RabbitMQ."""
    messages = []
    
    async def handler(message):
        messages.append(message)
    
    await message_consumer.subscribe("user.events", handler)
    # Wait for messages and verify
    assert len(messages) > 0
```

## Test Configuration
```python
# conftest.py
import pytest
import asyncio
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from app.database import Base
from app.models import *

# Test database URL
TEST_DATABASE_URL = "postgresql+asyncpg://test_user:test_pass@localhost:5432/test_db"

@pytest.fixture(scope="session")
def event_loop():
    """Create event loop for async tests."""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture(scope="session")
async def test_engine():
    """Create test database engine."""
    engine = create_async_engine(TEST_DATABASE_URL, echo=True)
    
    # Create tables
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    
    yield engine
    
    # Drop tables
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)
    
    await engine.dispose()

@pytest.fixture
async def test_db(test_engine):
    """Create test database session."""
    async_session = sessionmaker(
        test_engine, class_=AsyncSession, expire_on_commit=False
    )
    async with async_session() as session:
        yield session
```

## Coverage Requirements
- Use pytest-cov to measure coverage
- Set minimum coverage threshold to 100% for new code
- Generate coverage reports in HTML and XML formats
- Fail CI/CD pipeline if coverage drops below threshold

## Service-Specific Testing Requirements

### FastAPI Services
- Write async tests with `httpx.AsyncClient` and lifespan
- Provide standard fixtures (app, db, cache, broker), data factories, and reset utilities
- Use contract tests to validate responses against OpenAPI
- Provide golden examples for success/errors
- Make dependencies override-friendly in tests
- Use dependency injection for testing external services

### Aiogram Services
- Test bot handlers with mocked bot instances
- Test middleware functionality separately
- Use aiogram test utilities for message simulation
- Test Request ID propagation in handlers
- Test Redis and RabbitMQ integration within single event loop

### AsyncIO Worker Services
- Test worker lifecycle (startup, shutdown, task processing)
- Test Request ID generation and propagation in worker tasks
- Test Redis and RabbitMQ integration within asyncio event loop without creating conflicting event loops
- Use async test patterns with pytest-asyncio for all worker operations
- Test proper resource cleanup and signal handling

## Integration Testing with External Dependencies
- Use testcontainers for all stateful dependencies:
  - PostgreSQL for database operations
  - Redis for caching and idempotency
  - RabbitMQ for message queuing
  - ChromaDB for vector operations
- Ensure test fixtures work within existing asyncio event loop
- Test Redis client connection pooling and idempotency logic
- Test RabbitMQ connection reliability and message handling
- Test database transactions and rollback scenarios

## Test Commands
```bash
# Run all tests
pytest

# Run with coverage
pytest --cov=app --cov-report=html --cov-report=xml

# Run specific test types
pytest tests/unit/
pytest tests/integration/
pytest tests/e2e/

# Run with verbose output
pytest -v

# Run specific test file
pytest tests/unit/test_user_service.py -v
```
