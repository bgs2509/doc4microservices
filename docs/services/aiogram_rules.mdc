---
description: AIOgram standard for Python microservices, focuses on clean architecture, asynchronous processing, Pydantic DTO usage, RabbitMQ event publishing, and Redis integration.
globs: ["src/**/*.py"]
alwaysApply: true
---

### Title
Aiogram Rules (Python, Clean Architecture, RabbitMQ and Redis Integration)

### Version and Date
- Version: v2.0.0
- Updated: 2025-09-19
- Owner: rules/architecture

### Purpose
Define a unified standard for developing Telegram bots on Aiogram in the context of microservice architecture, ensuring reliability, tracing (Request ID), idempotency, RabbitMQ integration, and Redis dependency injection in a single event loop.

### Scope
- Covers: bot and dispatcher initialization, handler registration, asynchronous lifecycle management (lifespan), media file processing, RabbitMQ event publishing, Redis dependency injection, and single event loop management.
- Excludes: does not cover FastAPI rules, RabbitMQ, logging, or general microservice practices (see `fastapi_rules.mdc`, `rabbitmq_rules.mdc`, `logging_rules.mdc`, `ms_best_practices_rules.mdc`).

### Terms and Definitions
- **Bot**: Instance of `aiogram.Bot`.
- **Dispatcher**: Instance of `aiogram.Dispatcher`, managing routing and event processing.
- **Request ID**: Cross-cutting request identifier for full tracing.
- **DTO**: Pydantic `BaseModel` for messages, providing validation and serialization.
- **Redis Dependency**: Redis client registered as dependency in Aiogram Dispatcher for handler injection.
- **RabbitMQ Dependency**: RabbitMQ client registered as dependency in Aiogram Dispatcher for handler injection.

### Rules
1) **Initialization and startup**
   - **MUST:** Follow logging patterns as defined in `logging_rules.mdc`.
   - **MUST:** Use `asyncio.run(dp.start_polling(bot))` to start the bot in the main service file `zd_tg_photo_upload_api`.
   - **MUST:** Initialize `Bot` and `Dispatcher` only once at application startup.
   - **MUST:** Use `async with` for managing bot lifecycle and other dependencies, such as RabbitMQ and Redis connections, as part of `lifespan`.
   - **MUST:** Register Redis client as dependency using `dp.startup.register(lambda: {"redis": redis_client})` for single event loop compatibility.
   - **MUST:** Register RabbitMQ client as dependency using `dp.startup.register(lambda: {"rabbitmq": rabbitmq_client})` for single event loop compatibility.

2) **Event processing**
   - **MUST:** Process incoming events (messages, media) using `router.message()` and other appropriate handlers.
   - **MUST:** Extract `file_id` and other metadata from the `Message` object for further processing.
   - **SHOULD:** Add custom Middleware for generating and propagating `Request ID` in the context of each incoming Telegram message.

3) **Event publishing**
   - **MUST:** Publish `photo.received` event to `RabbitMQ` after successful photo reception from user, using `Request ID` in headers.
   - **MUST:** Use Pydantic-based DTOs, such as `PhotoReceivedPayloadDTO`, for structuring data before publishing.
   - **SHOULD:** Validate Telegram message data using Pydantic if necessary.

4) **Dependency management**
   - **MUST:** Use Aiogram's standard `Dependency Injection` system for passing dependencies (e.g., `RabbitMQ` client, `Redis` client) to handlers.
   - **MUST:** Ensure that the Aiogram service (`zd_tg_photo_upload_api`) does not contain FastAPI routes to avoid conflicts with event loop.
   - **MUST:** Register all external dependencies (Redis, RabbitMQ) in Dispatcher startup to ensure single event loop compatibility.
   - **MUST NOT:** Use `asyncio.run()` or create separate event loops for external dependencies when used with Aiogram.

5) **Media file processing**
   - **MUST:** Download files using `aiogram.Bot.download(file_id, destination=...)` if technical specification of Service define the downloading.
   - **MUST:** Save file to disk with temporary name, then pass file path in RabbitMQ payload.
   - **SHOULD:** Handle exceptions related to file downloads and send appropriate notifications to user.

6) **External service integration**
   - **MUST:** Follow Redis integration patterns as defined in `redis_rules.mdc` for idempotency and caching.
   - **MUST:** Follow RabbitMQ integration patterns as defined in `rabbitmq_rules.mdc` for event publishing.
   - **MUST:** Register external clients (Redis, RabbitMQ) as dependencies using `dp.startup.register()`.
   - **MUST:** Use dependency injection in handlers: `async def handler(message: Message, redis: RedisClient, rabbitmq: RabbitMQClient)`.
   - **MUST:** Ensure all external service operations are compatible with Aiogram's event loop.

### Priorities and Compatibility
- Depends on: `ms_best_practices_rules.mdc` (system-wide standard), `logging_rules.mdc` (observability), `redis_rules.mdc` (Redis integration), `rabbitmq_rules.mdc` (messaging).
- Does not duplicate: FastAPI rules (see `fastapi_rules.mdc`), Redis patterns (see `redis_rules.mdc`), RabbitMQ patterns (see `rabbitmq_rules.mdc`).
- Conflicts: none; explicitly separated from `FastAPI`.

### Examples
```python
# Example bot initialization and startup with Redis and RabbitMQ integration
import asyncio
from aiogram import Bot, Dispatcher, Router
from src.schemas.events import PhotoReceivedPayloadDTO
from src.adapters.rabbitmq.photo_event_publisher import RabbitMQClient
from src.adapters.redis.idempotency_client import RedisClient
from src.core.logging import generate_request_id, set_request_id, logger

async def main():
    bot = Bot(token="TOKEN")
    dp = Dispatcher()
    router = Router()

    # Initialize Redis client
    redis_client = RedisClient("redis://localhost:6379")
    await redis_client.connect()

    # Initialize RabbitMQ client
    rabbitmq_client = RabbitMQClient("amqp://guest:guest@localhost:5672/")
    await rabbitmq_client.connect()

    # Register all dependencies in Dispatcher startup
    dp.startup.register(lambda: {
        "rabbitmq": rabbitmq_client,
        "redis": redis_client
    })

    # Register handlers
    router.message.register(handle_photo, content_types=["photo"])
    dp.include_router(router)

    # Start polling in single event loop
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())

# Example handler for receiving photos with Redis and RabbitMQ dependency injection
from aiogram.types import Message

async def handle_photo(message: Message, rabbitmq: RabbitMQClient, redis: RedisClient):
    request_id = generate_request_id("tg", user_id=message.from_user.id, chat_id=message.chat.id)
    set_request_id(request_id)

    # Check idempotency using Redis
    if not await redis.check_idempotency(request_id):
        logger.info(f"duplicate_photo_detected request_id={request_id}")
        return

    # Process photo (download)
    file = await message.photo[-1].download()

    # Cache photo metadata in Redis
    photo_metadata = {
        "file_id": message.photo[-1].file_id,
        "user_id": message.from_user.id,
        "chat_id": message.chat.id,
        "file_size": message.photo[-1].file_size,
        "width": message.photo[-1].width,
        "height": message.photo[-1].height
    }
    await redis.cache_data(f"photo:{message.photo[-1].file_id}", photo_metadata, ttl=3600)

    payload = PhotoReceivedPayloadDTO(
        file_path=file.path,
        user_id=message.from_user.id,
        chat_id=message.chat.id
    )

    # Publish event to RabbitMQ
    await rabbitmq.publish_photo_received(payload, request_id)

    logger.info(f"photo_processed request_id={request_id} file_id={message.photo[-1].file_id}")
```

```python
# Example test fixtures for Aiogram with RabbitMQ and Redis integration
import pytest
import pytest_asyncio
from aiogram import Bot, Dispatcher
from aiogram.test import make_mocked_bot
from testcontainers.rabbitmq import RabbitMqContainer
from testcontainers.redis import RedisContainer
from src.adapters.rabbitmq.photo_event_publisher import RabbitMQClient
from src.adapters.redis.idempotency_client import RedisClient

@pytest.fixture(scope="session")
def rabbitmq_container():
    with RabbitMqContainer("rabbitmq:3.13-management") as container:
        yield container

@pytest.fixture(scope="session")
def redis_container():
    with RedisContainer("redis:7-alpine") as container:
        yield container

@pytest.fixture
async def rabbitmq_client(rabbitmq_container):
    """RabbitMQ client for testing - uses existing event loop."""
    client = RabbitMQClient(rabbitmq_container.get_connection_url())
    await client.connect()
    yield client
    await client.close()

@pytest.fixture
async def redis_client(redis_container):
    """Redis client for testing - uses existing event loop."""
    client = RedisClient(redis_container.get_connection_url())
    await client.connect()
    yield client
    await client.close()

@pytest.fixture
async def aiogram_dp_with_dependencies(rabbitmq_client, redis_client):
    """Aiogram dispatcher with RabbitMQ and Redis dependencies for testing."""
    dp = Dispatcher()
    dp.startup.register(lambda: {
        "rabbitmq": rabbitmq_client,
        "redis": redis_client
    })
    yield dp

@pytest.fixture
async def mocked_bot():
    """Mocked Aiogram bot for testing."""
    return make_mocked_bot()

# Example Aiogram integration test
@pytest.mark.asyncio
async def test_aiogram_photo_handling_with_rabbitmq_redis(aiogram_dp_with_dependencies, mocked_bot):
    """Test photo handling with RabbitMQ and Redis integration."""
    from aiogram.types import Message, User, Chat, PhotoSize

    # Arrange
    user = User(id=123, is_bot=False, first_name="Test")
    chat = Chat(id=456, type="private")
    photo = PhotoSize(file_id="test_file_123", file_unique_id="unique_123", width=100, height=100, file_size=1024)

    message = Message(
        message_id=1,
        from_user=user,
        chat=chat,
        date=1234567890,
        photo=[photo]
    )

    # Act - Process message through handler
    handler = aiogram_dp_with_dependencies._handlers[0].callback
    await handler(message, rabbitmq=aiogram_dp_with_dependencies._data["rabbitmq"], redis=aiogram_dp_with_dependencies._data["redis"])

    # Assert - Check Redis operations
    cached_data = await aiogram_dp_with_dependencies._data["redis"].get_cached_data("photo:test_file_123")
    assert cached_data is not None
    assert cached_data["file_id"] == "test_file_123"
    assert cached_data["user_id"] == 123

    # Assert - Check RabbitMQ operations (implementation depends on RabbitMQClient)
    # This would typically involve checking a test queue or using a mock
```

### Verification
- How to verify:
  - Check usage of `asyncio.run(dp.start_polling(bot))` for bot startup.
  - Ensure `Bot` and `Dispatcher` are initialized only once at startup.
  - Verify Redis is registered as dependency using `dp.startup.register()`.
  - Verify RabbitMQ is registered as dependency using `dp.startup.register()`.
  - Verify presence of `Request ID` in RabbitMQ message headers.
  - Ensure use of Pydantic DTOs for message validation.
  - Check that Aiogram service does not contain FastAPI routes.
  - Verify proper file download and temporary storage handling.
  - Ensure no `asyncio.run()` calls for external dependencies when used with Aiogram.
  - Verify Redis and RabbitMQ dependency injection in handlers.
  - Run Aiogram tests with `pytest tests/integration/test_aiogram_integration.py`.
- Success criteria:
  - Bot starts correctly; Request ID is propagated; DTOs are validated; RabbitMQ events published; Redis and RabbitMQ dependency injection working; no FastAPI conflicts; no event loop conflicts; comprehensive test coverage achieved.

### Changes
- 2025-01-27 v1.2.0: Added RabbitMQ integration rules for Aiogram, dependency injection patterns, event loop compatibility requirements, and updated test fixtures for Aiogram compatibility with both Redis and RabbitMQ.
- 2025-01-27 v1.1.0: Added Redis integration rules, dependency injection patterns, single event loop management, and updated examples for Redis compatibility.
- 2025-09-11 v1.0.0: Initial Aiogram rules for Python microservices with clean architecture, Request ID integration, and RabbitMQ event publishing.
